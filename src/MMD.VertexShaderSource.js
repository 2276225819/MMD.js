(function() {

  MMD.VertexShaderSource = '\nuniform mat4 uMVMatrix; // model-view matrix (model -> view space)\nuniform mat4 uPMatrix; // projection matrix (view -> projection space)\nuniform mat4 uNMatrix; // normal matrix (inverse of transpose of model-view matrix)\n\nuniform mat4 uLightMatrix; // mvpdMatrix of light space (model -> display space)\n\nattribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nattribute vec2 aTextureCoord;\nattribute float aVertexEdge; // 0 or 1. 1 if the vertex has an edge. (becuase we can\'t pass bool to attributes)\n\nuniform bool uBoneMotion;\nuniform vec3 uBonePosOriginal[64];\nuniform vec3 uBonePosMoved[64];\nuniform vec4 uBoneRotations[64]; // quaternion\n\nattribute float aBone1;\nattribute float aBone2;\nattribute float aBoneWeight;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vTextureCoord;\nvarying vec4 vLightCoord; // coordinate in light space; to be mapped onto shadow map\n\nuniform float uEdgeThickness;\nuniform bool uEdge;\n\nuniform bool uGenerateShadowMap;\n\nuniform bool uSelfShadow;\n\nuniform bool uAxis;\nuniform bool uCenterPoint;\n\nvec3 qtransform(vec4 q, vec3 v) {\n  return v + 2.0 * cross(cross(v, q.xyz) - q.w*v, q.xyz);\n}\n\nvoid main() {\n  vec3 position = aVertexPosition;\n  vec3 normal = aVertexNormal;\n\n  if (uBoneMotion) {\n    int b1 = int(aBone1);\n    vec3 o1 = uBonePosOriginal[b1];\n    vec3 p1 = uBonePosMoved[b1];\n    vec4 q1 = uBoneRotations[b1];\n    vec3 r1 = qtransform(q1, position - o1) + p1;\n\n    int b2 = int(aBone2);\n    vec3 o2 = uBonePosOriginal[b2];\n    vec3 p2 = uBonePosMoved[b2];\n    vec4 q2 = uBoneRotations[b2];\n    vec3 r2 = qtransform(q2, position - o2) + p2;\n\n    position = mix(r2, r1, aBoneWeight);\n\n    vec3 n1 = qtransform(q1, normal);\n    vec3 n2 = qtransform(q2, normal);\n\n    normal = normalize(mix(n2, n1, aBoneWeight));\n  }\n\n  // return vertex point in projection space\n  gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);\n\n  if (uCenterPoint) {\n    gl_Position.z = 0.0; // always on top\n    gl_PointSize = 16.0;\n  }\n\n  if (uGenerateShadowMap || uAxis || uCenterPoint) return;\n\n  // for fragment shader\n  vTextureCoord = aTextureCoord;\n  vPosition = (uMVMatrix * vec4(position, 1.0)).xyz;\n  vNormal = (uNMatrix * vec4(normal, 1.0)).xyz;\n\n  if (uSelfShadow) {\n    vLightCoord = uLightMatrix * vec4(position, 1.0);\n  }\n\n  if (uEdge) {\n    vec4 pos = gl_Position;\n    vec4 pos2 = uPMatrix * uMVMatrix * vec4(position + normal, 1.0);\n    vec4 norm = normalize(pos2 - pos);\n    gl_Position = pos + norm * uEdgeThickness * aVertexEdge * pos.w; // scale by pos.w to prevent becoming thicker when zoomed\n    return;\n  }\n}\n';

}).call(this);
